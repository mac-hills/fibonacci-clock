{"ast":null,"code":"import { clockColors } from '../resources/color-resources/clockColors';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./local-storage.service\";\nexport class ColorService {\n  constructor(localStorageService) {\n    this.localStorageService = localStorageService;\n    this.CLOCK_COLORS_KEY = 'clockColors';\n    this.currentIndexBackgroundArray = 0;\n    this.currentIndexSecondsCounterArray = 0;\n    this.currentColorIndex = 0;\n    this.letters = '0123456789ABCDEF';\n    // generating a colors array for the background color\n    this.colorsArrayBackGround = [];\n    // generating a colors array for the seconds counter\n    this.colorsArraySecondsCounter = [];\n    // Load colors from localStorage or use defaults\n    this.colors = this.localStorageService.getItem(this.CLOCK_COLORS_KEY, {\n      ...clockColors\n    });\n    // Initialize color arrays\n    this.regenerateColorArrays();\n  }\n  // Access all clock colors\n  getClockColors() {\n    return this.colors;\n  }\n  // Update a specific color and save to localStorage\n  updateColor(colorKey, colorValue) {\n    this.colors[colorKey] = colorValue;\n    this.saveColors();\n    this.regenerateColorArrays();\n  }\n  // Save all colors to localStorage\n  saveColors() {\n    this.localStorageService.setItem(this.CLOCK_COLORS_KEY, this.colors);\n  }\n  // Reset colors to default\n  resetColors() {\n    this.colors = {\n      ...clockColors\n    };\n    this.saveColors();\n    this.regenerateColorArrays();\n  }\n  // Regenerate color arrays based on current color settings\n  regenerateColorArrays() {\n    const clockBackGroundColorArrayStartColor = this.getClockBackgroundColorStart();\n    const clockBackGroundColorArrayEndColor = this.getClockBackgroundColorEnd();\n    const clockBackGroundColorSteps = 60;\n    const startColorSecondsCounter = this.getSecondsCounterArrayStartColor();\n    const endColorSecondsCounter = this.getSecondsCounterArrayEndColor();\n    const stepsSecondsCounter = 1;\n    this.colorsArrayBackGround = this.generateColorArray(clockBackGroundColorArrayStartColor, clockBackGroundColorArrayEndColor, clockBackGroundColorSteps);\n    this.colorsArraySecondsCounter = this.generateColorArray(startColorSecondsCounter, endColorSecondsCounter, stepsSecondsCounter);\n  }\n  // Access specific colors\n  getColorWhenUsedForHoursAndMinutes() {\n    return this.colors['colorWhenUsedForHoursAndMinutes'];\n  }\n  getColorWhenUsedForHours() {\n    return this.colors['colorWhenUsedForHours'];\n  }\n  getColorWhenUsedForMinutes() {\n    return this.colors['colorWhenUsedForMinutes'];\n  }\n  getColorWhenNotUsed() {\n    return this.colors['colorWhenNotUsed'];\n  }\n  getClockBackgroundColorStart() {\n    return this.colors['clockBackGroundColorArrayStartColor'];\n  }\n  getClockBackgroundColorEnd() {\n    return this.colors['clockBackGroundColorArrayEndColor'];\n  }\n  getSecondsCounterArrayStartColor() {\n    return this.colors['secondsCounterArrayStartColor'];\n  }\n  getSecondsCounterArrayEndColor() {\n    return this.colors['secondsCounterArrayEndColor'];\n  }\n  getColorsArryForBackground() {\n    return this.colorsArrayBackGround;\n  }\n  getColorsArryForSecondsCounterShape() {\n    return this.colorsArraySecondsCounter;\n  }\n  getRandomColor() {\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n      color += this.letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n  getNextColorForBackground() {\n    const color = this.colorsArrayBackGround[this.currentIndexBackgroundArray];\n    this.currentIndexBackgroundArray = (this.currentIndexBackgroundArray + 1) % this.colorsArrayBackGround.length;\n    return color;\n  }\n  getNextColorFromSecondsCounter(array) {\n    const color = array[this.currentIndexSecondsCounterArray];\n    this.currentIndexSecondsCounterArray = (this.currentIndexSecondsCounterArray + 1) % this.colorsArraySecondsCounter.length;\n    return color;\n  }\n  // these methods generates an array of colors that gradually changes from the starting color to the end color in a given number of steps\n  generateColorArray(startColor, endColor, steps) {\n    const colorsArray = [];\n    const startRGB = this.extractRGBValues(startColor);\n    const endRGB = this.extractRGBValues(endColor);\n    for (let i = 0; i <= steps; i++) {\n      const currentColor = this.interpolateColor(startRGB, endRGB, i / steps);\n      colorsArray.push(`rgb(${currentColor.join(',')})`);\n    }\n    return colorsArray;\n  }\n  extractRGBValues(color) {\n    const matchResult = color.match(/\\d+/g);\n    if (matchResult) {\n      return matchResult.map(Number);\n    } else {\n      console.error('Invalid color format');\n      return [];\n    }\n  }\n  interpolateColor(startColor, endColor, ratio) {\n    return startColor.map((component, index) => Math.round(component + (endColor[index] - component) * ratio));\n  }\n  static #_ = this.ɵfac = function ColorService_Factory(t) {\n    return new (t || ColorService)(i0.ɵɵinject(i1.LocalStorageService));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ColorService,\n    factory: ColorService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["clockColors","ColorService","constructor","localStorageService","CLOCK_COLORS_KEY","currentIndexBackgroundArray","currentIndexSecondsCounterArray","currentColorIndex","letters","colorsArrayBackGround","colorsArraySecondsCounter","colors","getItem","regenerateColorArrays","getClockColors","updateColor","colorKey","colorValue","saveColors","setItem","resetColors","clockBackGroundColorArrayStartColor","getClockBackgroundColorStart","clockBackGroundColorArrayEndColor","getClockBackgroundColorEnd","clockBackGroundColorSteps","startColorSecondsCounter","getSecondsCounterArrayStartColor","endColorSecondsCounter","getSecondsCounterArrayEndColor","stepsSecondsCounter","generateColorArray","getColorWhenUsedForHoursAndMinutes","getColorWhenUsedForHours","getColorWhenUsedForMinutes","getColorWhenNotUsed","getColorsArryForBackground","getColorsArryForSecondsCounterShape","getRandomColor","color","i","Math","floor","random","getNextColorForBackground","length","getNextColorFromSecondsCounter","array","startColor","endColor","steps","colorsArray","startRGB","extractRGBValues","endRGB","currentColor","interpolateColor","push","join","matchResult","match","map","Number","console","error","ratio","component","index","round","_","i0","ɵɵinject","i1","LocalStorageService","_2","factory","ɵfac","providedIn"],"sources":["C:\\apps\\fibonacci-clock-24h-60min-merged\\src\\app\\services\\color.service.ts"],"sourcesContent":["// src/app/services/color.service.ts\r\nimport { Injectable } from '@angular/core';\r\nimport { clockColors } from '../resources/color-resources/clockColors';\r\nimport { LocalStorageService } from './local-storage.service';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ColorService {\r\n  private readonly CLOCK_COLORS_KEY = 'clockColors';\r\n  private colors: { [key: string]: string };\r\n\r\n  public currentIndexBackgroundArray = 0;\r\n  public currentIndexSecondsCounterArray = 0;\r\n  public currentColorIndex = 0;\r\n  private letters = '0123456789ABCDEF';\r\n\r\n  // generating a colors array for the background color\r\n  public colorsArrayBackGround: string[] = [];\r\n\r\n  // generating a colors array for the seconds counter\r\n  public colorsArraySecondsCounter: string[] = [];\r\n\r\n  constructor(private localStorageService: LocalStorageService) {\r\n    // Load colors from localStorage or use defaults\r\n    this.colors = this.localStorageService.getItem<{ [key: string]: string }>(\r\n      this.CLOCK_COLORS_KEY,\r\n      { ...clockColors }\r\n    );\r\n\r\n    // Initialize color arrays\r\n    this.regenerateColorArrays();\r\n  }\r\n\r\n  // Access all clock colors\r\n  getClockColors() {\r\n    return this.colors;\r\n  }\r\n\r\n  // Update a specific color and save to localStorage\r\n  updateColor(colorKey: string, colorValue: string): void {\r\n    this.colors[colorKey] = colorValue;\r\n    this.saveColors();\r\n    this.regenerateColorArrays();\r\n  }\r\n\r\n  // Save all colors to localStorage\r\n  saveColors(): void {\r\n    this.localStorageService.setItem(this.CLOCK_COLORS_KEY, this.colors);\r\n  }\r\n\r\n  // Reset colors to default\r\n  resetColors(): void {\r\n    this.colors = { ...clockColors };\r\n    this.saveColors();\r\n    this.regenerateColorArrays();\r\n  }\r\n\r\n  // Regenerate color arrays based on current color settings\r\n  regenerateColorArrays(): void {\r\n    const clockBackGroundColorArrayStartColor = this.getClockBackgroundColorStart();\r\n    const clockBackGroundColorArrayEndColor = this.getClockBackgroundColorEnd();\r\n    const clockBackGroundColorSteps = 60;\r\n\r\n    const startColorSecondsCounter = this.getSecondsCounterArrayStartColor();\r\n    const endColorSecondsCounter = this.getSecondsCounterArrayEndColor();\r\n    const stepsSecondsCounter = 1;\r\n\r\n    this.colorsArrayBackGround = this.generateColorArray(\r\n      clockBackGroundColorArrayStartColor,\r\n      clockBackGroundColorArrayEndColor,\r\n      clockBackGroundColorSteps\r\n    );\r\n\r\n    this.colorsArraySecondsCounter = this.generateColorArray(\r\n      startColorSecondsCounter,\r\n      endColorSecondsCounter,\r\n      stepsSecondsCounter\r\n    );\r\n  }\r\n\r\n  // Access specific colors\r\n  getColorWhenUsedForHoursAndMinutes() {\r\n    return this.colors['colorWhenUsedForHoursAndMinutes'];\r\n  }\r\n\r\n  getColorWhenUsedForHours() {\r\n    return this.colors['colorWhenUsedForHours'];\r\n  }\r\n\r\n  getColorWhenUsedForMinutes() {\r\n    return this.colors['colorWhenUsedForMinutes'];\r\n  }\r\n\r\n  getColorWhenNotUsed() {\r\n    return this.colors['colorWhenNotUsed'];\r\n  }\r\n\r\n  getClockBackgroundColorStart() {\r\n    return this.colors['clockBackGroundColorArrayStartColor'];\r\n  }\r\n\r\n  getClockBackgroundColorEnd() {\r\n    return this.colors['clockBackGroundColorArrayEndColor'];\r\n  }\r\n\r\n  getSecondsCounterArrayStartColor() {\r\n    return this.colors['secondsCounterArrayStartColor'];\r\n  }\r\n\r\n  getSecondsCounterArrayEndColor() {\r\n    return this.colors['secondsCounterArrayEndColor'];\r\n  }\r\n\r\n  getColorsArryForBackground() {\r\n    return this.colorsArrayBackGround;\r\n  }\r\n\r\n  getColorsArryForSecondsCounterShape() {\r\n    return this.colorsArraySecondsCounter;\r\n  }\r\n\r\n  getRandomColor(): string {\r\n    let color = '#';\r\n    for (let i = 0; i < 6; i++) {\r\n      color += this.letters[Math.floor(Math.random() * 16)];\r\n    }\r\n    return color;\r\n  }\r\n\r\n  getNextColorForBackground() {\r\n    const color = this.colorsArrayBackGround[this.currentIndexBackgroundArray];\r\n    this.currentIndexBackgroundArray = (this.currentIndexBackgroundArray + 1) % this.colorsArrayBackGround.length;\r\n    return color;\r\n  }\r\n\r\n  getNextColorFromSecondsCounter(array: string[]): string {\r\n    const color = array[this.currentIndexSecondsCounterArray];\r\n    this.currentIndexSecondsCounterArray = (this.currentIndexSecondsCounterArray + 1) % this.colorsArraySecondsCounter.length;\r\n    return color;\r\n  }\r\n\r\n  // these methods generates an array of colors that gradually changes from the starting color to the end color in a given number of steps\r\n  generateColorArray(startColor: string, endColor: string, steps: number): string[] {\r\n    const colorsArray = [];\r\n    const startRGB = this.extractRGBValues(startColor);\r\n    const endRGB = this.extractRGBValues(endColor);\r\n    for (let i = 0; i <= steps; i++) {\r\n      const currentColor = this.interpolateColor(startRGB, endRGB, i / steps);\r\n      colorsArray.push(`rgb(${currentColor.join(',')})`);\r\n    }\r\n    return colorsArray;\r\n  }\r\n\r\n  private extractRGBValues(color: string): number[] {\r\n    const matchResult = color.match(/\\d+/g);\r\n    if (matchResult) {\r\n      return matchResult.map(Number);\r\n    } else {\r\n      console.error('Invalid color format');\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private interpolateColor(startColor: number[], endColor: number[], ratio: number): number[] {\r\n    return startColor.map((component, index) =>\r\n      Math.round(component + (endColor[index] - component) * ratio)\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}