{"ast":null,"code":"import { clockColors } from '../resources/color-resources/clockColors';\nimport * as i0 from \"@angular/core\";\nexport class ColorService {\n  // Access all clock colors\n  getClockColors() {\n    return clockColors;\n  }\n  // Access specific colors\n  getColorWhenUsedForHoursAndMinutes() {\n    return clockColors.colorWhenUsedForHoursAndMinutes;\n  }\n  getColorWhenUsedForHours() {\n    return clockColors.colorWhenUsedForHours;\n  }\n  getColorWhenUsedForMinutes() {\n    return clockColors.colorWhenUsedForMinutes;\n  }\n  getColorWhenNotUsed() {\n    return clockColors.colorWhenNotUsed;\n  }\n  getClockBackgroundColorStart() {\n    return clockColors.clockBackGroundColorArrayStartColor;\n  }\n  getClockBackgroundColorEnd() {\n    return clockColors.clockBackGroundColorArrayEndColor;\n  }\n  getSecondsCounterArrayStartColor() {\n    return clockColors.secondsCounterArrayStartColor;\n  }\n  getSecondsCounterArrayEndColor() {\n    return clockColors.secondsCounterArrayEndColor;\n  }\n  constructor() {\n    this.currentIndexBackgroundArray = 0;\n    this.currentIndexSecondsCounterArray = 0;\n    this.currentColorIndex = 0;\n    this.letters = '0123456789ABCDEF';\n    // generating a colors array for the background color\n    this.colorsArrayBackGround = [];\n    this.clockBackGroundColorArrayStartColor = this.getClockBackgroundColorStart();\n    this.clockBackGroundColorArrayEndColor = this.getClockBackgroundColorEnd();\n    this.clockBackGroundColorSteps = 60;\n    // generating a colors array for the background color\n    this.colorsArraySecondsCounter = [];\n    this.startColorSecondsCounter = this.getSecondsCounterArrayStartColor();\n    this.endColorSecondsCounter = this.getSecondsCounterArrayEndColor();\n    this.stepsSecondsCounter = 1;\n    this.colorsArrayBackGround = this.generateColorArray(this.clockBackGroundColorArrayStartColor, this.clockBackGroundColorArrayEndColor, this.clockBackGroundColorSteps);\n    this.colorsArraySecondsCounter = this.generateColorArray(this.startColorSecondsCounter, this.endColorSecondsCounter, this.stepsSecondsCounter);\n  }\n  getColorsArryForBackground() {\n    return this.colorsArrayBackGround;\n  }\n  getColorsArryForSecondsCounterShape() {\n    return this.colorsArraySecondsCounter;\n  }\n  getRandomColor() {\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n      color += this.letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n  // getNextColor() {\n  //   const color = this.colorsArrayBackGround[this.currentColorIndex];\n  //   this.currentColorIndex = (this.currentColorIndex + 1) % this.colorsArrayBackGround.length;\n  //   return color;\n  // }\n  getNextColorForBackground() {\n    const color = this.colorsArrayBackGround[this.currentIndexBackgroundArray];\n    this.currentIndexBackgroundArray = (this.currentIndexBackgroundArray + 1) % this.colorsArrayBackGround.length;\n    return color;\n  }\n  getNextColorFromSecondsCounter(array) {\n    const color = array[this.currentIndexSecondsCounterArray];\n    this.currentIndexSecondsCounterArray = (this.currentIndexSecondsCounterArray + 1) % this.colorsArraySecondsCounter.length;\n    return color;\n  }\n  // these methods generates an array of colors that gradually changes from the starting color to the end color in a given number of steps (use 60 if you want to match a minute)\n  generateColorArray(startColor, endColor, steps) {\n    const colorsArray = [];\n    const startRGB = this.extractRGBValues(startColor);\n    const endRGB = this.extractRGBValues(endColor);\n    for (let i = 0; i <= steps; i++) {\n      const currentColor = this.interpolateColor(startRGB, endRGB, i / steps);\n      colorsArray.push(`rgb(${currentColor.join(',')})`);\n    }\n    return colorsArray;\n  }\n  extractRGBValues(color) {\n    const matchResult = color.match(/\\d+/g);\n    if (matchResult) {\n      return matchResult.map(Number);\n    } else {\n      console.error('Invalid color format');\n      return [];\n    }\n  }\n  interpolateColor(startColor, endColor, ratio) {\n    return startColor.map((component, index) => Math.round(component + (endColor[index] - component) * ratio));\n  }\n  static #_ = this.ɵfac = function ColorService_Factory(t) {\n    return new (t || ColorService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ColorService,\n    factory: ColorService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["clockColors","ColorService","getClockColors","getColorWhenUsedForHoursAndMinutes","colorWhenUsedForHoursAndMinutes","getColorWhenUsedForHours","colorWhenUsedForHours","getColorWhenUsedForMinutes","colorWhenUsedForMinutes","getColorWhenNotUsed","colorWhenNotUsed","getClockBackgroundColorStart","clockBackGroundColorArrayStartColor","getClockBackgroundColorEnd","clockBackGroundColorArrayEndColor","getSecondsCounterArrayStartColor","secondsCounterArrayStartColor","getSecondsCounterArrayEndColor","secondsCounterArrayEndColor","constructor","currentIndexBackgroundArray","currentIndexSecondsCounterArray","currentColorIndex","letters","colorsArrayBackGround","clockBackGroundColorSteps","colorsArraySecondsCounter","startColorSecondsCounter","endColorSecondsCounter","stepsSecondsCounter","generateColorArray","getColorsArryForBackground","getColorsArryForSecondsCounterShape","getRandomColor","color","i","Math","floor","random","getNextColorForBackground","length","getNextColorFromSecondsCounter","array","startColor","endColor","steps","colorsArray","startRGB","extractRGBValues","endRGB","currentColor","interpolateColor","push","join","matchResult","match","map","Number","console","error","ratio","component","index","round","_","_2","factory","ɵfac","providedIn"],"sources":["C:\\apps\\fibonacci-clock-24h-60min-merged\\src\\app\\services\\color.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { clockColors } from '../resources/color-resources/clockColors';\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ColorService {\r\n  // Access all clock colors\r\n  getClockColors() {\r\n    return clockColors;\r\n  }\r\n\r\n  // Access specific colors\r\n  getColorWhenUsedForHoursAndMinutes() {\r\n    return clockColors.colorWhenUsedForHoursAndMinutes;\r\n  }\r\n\r\n  getColorWhenUsedForHours() {\r\n    return clockColors.colorWhenUsedForHours;\r\n  }\r\n\r\n  getColorWhenUsedForMinutes() {\r\n    return clockColors.colorWhenUsedForMinutes;\r\n  }\r\n\r\n  getColorWhenNotUsed() {\r\n    return clockColors.colorWhenNotUsed;\r\n  }\r\n\r\n  getClockBackgroundColorStart() {\r\n    return clockColors.clockBackGroundColorArrayStartColor;\r\n  }\r\n\r\n  getClockBackgroundColorEnd() {\r\n    return clockColors.clockBackGroundColorArrayEndColor;\r\n  }\r\n\r\n  getSecondsCounterArrayStartColor() {\r\n    return clockColors.secondsCounterArrayStartColor;\r\n  }\r\n\r\n  getSecondsCounterArrayEndColor() {\r\n    return clockColors.secondsCounterArrayEndColor;\r\n  }\r\n\r\n  public currentIndexBackgroundArray = 0;\r\n  public currentIndexSecondsCounterArray = 0;\r\n  public currentColorIndex = 0;\r\n  private letters = '0123456789ABCDEF';\r\n\r\n  // generating a colors array for the background color\r\n  public colorsArrayBackGround: string[] = [];\r\n  clockBackGroundColorArrayStartColor = this.getClockBackgroundColorStart();\r\n  clockBackGroundColorArrayEndColor = this.getClockBackgroundColorEnd();\r\n  clockBackGroundColorSteps = 60;\r\n\r\n  // generating a colors array for the background color\r\n  public colorsArraySecondsCounter: string[] = [];\r\n  startColorSecondsCounter = this.getSecondsCounterArrayStartColor();\r\n  endColorSecondsCounter = this.getSecondsCounterArrayEndColor();\r\n  stepsSecondsCounter = 1;\r\n  \r\n  constructor() {\r\n    this.colorsArrayBackGround = this.generateColorArray(\r\n      this.clockBackGroundColorArrayStartColor, \r\n      this.clockBackGroundColorArrayEndColor, \r\n      this.clockBackGroundColorSteps);\r\n\r\n    this.colorsArraySecondsCounter = this.generateColorArray(\r\n      this.startColorSecondsCounter, \r\n      this.endColorSecondsCounter, \r\n      this.stepsSecondsCounter);\r\n  }\r\n  \r\n  getColorsArryForBackground(){\r\n    return this.colorsArrayBackGround;\r\n  }\r\n\r\n  getColorsArryForSecondsCounterShape(){\r\n    return this.colorsArraySecondsCounter;\r\n  }\r\n \r\n  getRandomColor(): string {\r\n    let color = '#';\r\n    for (let i = 0; i < 6; i++) {\r\n      color += this.letters[Math.floor(Math.random() * 16)];\r\n    }\r\n    return color;\r\n  }\r\n\r\n  // getNextColor() {\r\n  //   const color = this.colorsArrayBackGround[this.currentColorIndex];\r\n  //   this.currentColorIndex = (this.currentColorIndex + 1) % this.colorsArrayBackGround.length;\r\n  //   return color;\r\n  // }\r\n\r\n  getNextColorForBackground() {\r\n    const color = this.colorsArrayBackGround[this.currentIndexBackgroundArray];\r\n    this.currentIndexBackgroundArray = (this.currentIndexBackgroundArray + 1) % this.colorsArrayBackGround.length;\r\n    return color;\r\n  }\r\n  \r\n  getNextColorFromSecondsCounter(array: string[]): string {\r\n    const color = array[this.currentIndexSecondsCounterArray];\r\n    this.currentIndexSecondsCounterArray = (this.currentIndexSecondsCounterArray + 1) % this.colorsArraySecondsCounter.length;\r\n    return color;\r\n  }\r\n\r\n  // these methods generates an array of colors that gradually changes from the starting color to the end color in a given number of steps (use 60 if you want to match a minute)\r\n  generateColorArray(startColor: string, endColor: string, steps: number): string[] {\r\n    const colorsArray = [];\r\n    const startRGB = this.extractRGBValues(startColor);\r\n    const endRGB = this.extractRGBValues(endColor);\r\n    for (let i = 0; i <= steps; i++) {\r\n      const currentColor = this.interpolateColor(startRGB, endRGB, i / steps);\r\n      colorsArray.push(`rgb(${currentColor.join(',')})`);\r\n    }\r\n    return colorsArray;\r\n  }\r\n\r\n  private extractRGBValues(color: string): number[] {\r\n    const matchResult = color.match(/\\d+/g);\r\n    if (matchResult) {\r\n      return matchResult.map(Number);\r\n    } else {\r\n      console.error('Invalid color format');\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private interpolateColor(startColor: number[], endColor: number[], ratio: number): number[] {\r\n    return startColor.map((component, index) =>\r\n      Math.round(component + (endColor[index] - component) * ratio)\r\n    );\r\n  }\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}