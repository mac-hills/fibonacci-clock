{"ast":null,"code":"import { clockColors } from '../resources/color-resources/clockColors';\nimport * as i0 from \"@angular/core\";\nexport class ColorService {\n  // Access all clock colors\n  getClockColors() {\n    return clockColors;\n  }\n  // Access specific colors\n  getColorWhenUsedForHoursAndMinutes() {\n    return clockColors['colorWhenUsedForHoursAndMinutes'];\n  }\n  getColorWhenUsedForHours() {\n    return clockColors['colorWhenUsedForHours'];\n  }\n  getColorWhenUsedForMinutes() {\n    return clockColors['colorWhenUsedForMinutes'];\n  }\n  getColorWhenNotUsed() {\n    return clockColors['colorWhenNotUsed'];\n  }\n  getClockBackgroundColorStart() {\n    return clockColors['clockBackGroundColorArrayStartColor'];\n  }\n  getClockBackgroundColorEnd() {\n    return clockColors['clockBackGroundColorArrayEndColor'];\n  }\n  getSecondsCounterArrayStartColor() {\n    return clockColors['secondsCounterArrayStartColor'];\n  }\n  getSecondsCounterArrayEndColor() {\n    return clockColors['secondsCounterArrayEndColor'];\n  }\n  constructor() {\n    this.currentIndexBackgroundArray = 0;\n    this.currentIndexSecondsCounterArray = 0;\n    this.currentColorIndex = 0;\n    this.letters = '0123456789ABCDEF';\n    // generating a colors array for the background color\n    this.colorsArrayBackGround = [];\n    this.clockBackGroundColorArrayStartColor = this.getClockBackgroundColorStart();\n    this.clockBackGroundColorArrayEndColor = this.getClockBackgroundColorEnd();\n    this.clockBackGroundColorSteps = 60;\n    // generating a colors array for the seconds counter\n    this.colorsArraySecondsCounter = [];\n    this.startColorSecondsCounter = this.getSecondsCounterArrayStartColor();\n    this.endColorSecondsCounter = this.getSecondsCounterArrayEndColor();\n    this.stepsSecondsCounter = 1;\n    this.colorsArrayBackGround = this.generateColorArray(this.clockBackGroundColorArrayStartColor, this.clockBackGroundColorArrayEndColor, this.clockBackGroundColorSteps);\n    this.colorsArraySecondsCounter = this.generateColorArray(this.startColorSecondsCounter, this.endColorSecondsCounter, this.stepsSecondsCounter);\n    console.log('Seconds Counter Colors:', this.colorsArraySecondsCounter);\n  }\n  getColorsArryForBackground() {\n    return this.colorsArrayBackGround;\n  }\n  getColorsArryForSecondsCounterShape() {\n    return this.colorsArraySecondsCounter;\n  }\n  getRandomColor() {\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n      color += this.letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n  // getNextColor() {\n  //   const color = this.colorsArrayBackGround[this.currentColorIndex];\n  //   this.currentColorIndex = (this.currentColorIndex + 1) % this.colorsArrayBackGround.length;\n  //   return color;\n  // }\n  getNextColorForBackground() {\n    const color = this.colorsArrayBackGround[this.currentIndexBackgroundArray];\n    this.currentIndexBackgroundArray = (this.currentIndexBackgroundArray + 1) % this.colorsArrayBackGround.length;\n    return color;\n  }\n  getNextColorFromSecondsCounter(array) {\n    const color = array[this.currentIndexSecondsCounterArray];\n    this.currentIndexSecondsCounterArray = (this.currentIndexSecondsCounterArray + 1) % this.colorsArraySecondsCounter.length;\n    return color;\n  }\n  // these methods generates an array of colors that gradually changes from the starting color to the end color in a given number of steps (use 60 if you want to match a minute)\n  generateColorArray(startColor, endColor, steps) {\n    const colorsArray = [];\n    const startRGB = this.extractRGBValues(startColor);\n    const endRGB = this.extractRGBValues(endColor);\n    for (let i = 0; i <= steps; i++) {\n      const currentColor = this.interpolateColor(startRGB, endRGB, i / steps);\n      colorsArray.push(`rgb(${currentColor.join(',')})`);\n    }\n    return colorsArray;\n  }\n  extractRGBValues(color) {\n    const matchResult = color.match(/\\d+/g);\n    if (matchResult) {\n      return matchResult.map(Number);\n    } else {\n      console.error('Invalid color format');\n      return [];\n    }\n  }\n  interpolateColor(startColor, endColor, ratio) {\n    return startColor.map((component, index) => Math.round(component + (endColor[index] - component) * ratio));\n  }\n  static #_ = this.ɵfac = function ColorService_Factory(t) {\n    return new (t || ColorService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ColorService,\n    factory: ColorService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["clockColors","ColorService","getClockColors","getColorWhenUsedForHoursAndMinutes","getColorWhenUsedForHours","getColorWhenUsedForMinutes","getColorWhenNotUsed","getClockBackgroundColorStart","getClockBackgroundColorEnd","getSecondsCounterArrayStartColor","getSecondsCounterArrayEndColor","constructor","currentIndexBackgroundArray","currentIndexSecondsCounterArray","currentColorIndex","letters","colorsArrayBackGround","clockBackGroundColorArrayStartColor","clockBackGroundColorArrayEndColor","clockBackGroundColorSteps","colorsArraySecondsCounter","startColorSecondsCounter","endColorSecondsCounter","stepsSecondsCounter","generateColorArray","console","log","getColorsArryForBackground","getColorsArryForSecondsCounterShape","getRandomColor","color","i","Math","floor","random","getNextColorForBackground","length","getNextColorFromSecondsCounter","array","startColor","endColor","steps","colorsArray","startRGB","extractRGBValues","endRGB","currentColor","interpolateColor","push","join","matchResult","match","map","Number","error","ratio","component","index","round","_","_2","factory","ɵfac","providedIn"],"sources":["C:\\apps\\fibonacci-clock-24h-60min-merged\\src\\app\\services\\color.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { clockColors } from '../resources/color-resources/clockColors';\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ColorService {\r\n  // Access all clock colors\r\n  getClockColors() {\r\n    return clockColors;\r\n  }\r\n\r\n  // Access specific colors\r\n  getColorWhenUsedForHoursAndMinutes() {\r\n    return clockColors['colorWhenUsedForHoursAndMinutes'];\r\n\r\n  }  \r\n  \r\n  getColorWhenUsedForHours() {\r\n    return clockColors['colorWhenUsedForHours'];\r\n  }\r\n\r\n  getColorWhenUsedForMinutes()  {\r\n    return clockColors['colorWhenUsedForMinutes'];\r\n  }\r\n\r\n  getColorWhenNotUsed()  {\r\n    return clockColors['colorWhenNotUsed'];\r\n  }\r\n\r\n  getClockBackgroundColorStart()  {\r\n    return clockColors['clockBackGroundColorArrayStartColor'];\r\n  }\r\n\r\n  getClockBackgroundColorEnd()  {\r\n    return clockColors['clockBackGroundColorArrayEndColor'];\r\n  }\r\n\r\n  getSecondsCounterArrayStartColor() {\r\n    return clockColors['secondsCounterArrayStartColor'];\r\n  }\r\n\r\n  getSecondsCounterArrayEndColor()  {\r\n    return clockColors['secondsCounterArrayEndColor'];\r\n  }\r\n\r\n  public currentIndexBackgroundArray = 0;\r\n  public currentIndexSecondsCounterArray = 0;\r\n  public currentColorIndex = 0;\r\n  private letters = '0123456789ABCDEF';\r\n\r\n  // generating a colors array for the background color\r\n  public colorsArrayBackGround: string[] = [];\r\n  clockBackGroundColorArrayStartColor = this.getClockBackgroundColorStart();\r\n  clockBackGroundColorArrayEndColor = this.getClockBackgroundColorEnd();\r\n  clockBackGroundColorSteps = 60;\r\n\r\n  // generating a colors array for the seconds counter\r\n  public colorsArraySecondsCounter: string[] = [];\r\n  startColorSecondsCounter = this.getSecondsCounterArrayStartColor();\r\n  endColorSecondsCounter = this.getSecondsCounterArrayEndColor();\r\n  stepsSecondsCounter = 1;\r\n  \r\n  constructor() {\r\n    this.colorsArrayBackGround = this.generateColorArray(\r\n      this.clockBackGroundColorArrayStartColor, \r\n      this.clockBackGroundColorArrayEndColor, \r\n      this.clockBackGroundColorSteps);\r\n\r\n    this.colorsArraySecondsCounter = this.generateColorArray(\r\n      this.startColorSecondsCounter, \r\n      this.endColorSecondsCounter, \r\n      this.stepsSecondsCounter);\r\n    console.log('Seconds Counter Colors:', this.colorsArraySecondsCounter);\r\n  }\r\n  \r\n  getColorsArryForBackground(){\r\n    return this.colorsArrayBackGround;\r\n  }\r\n\r\n  getColorsArryForSecondsCounterShape(){\r\n    return this.colorsArraySecondsCounter;\r\n  }\r\n \r\n  getRandomColor(): string {\r\n    let color = '#';\r\n    for (let i = 0; i < 6; i++) {\r\n      color += this.letters[Math.floor(Math.random() * 16)];\r\n    }\r\n    return color;\r\n  }\r\n\r\n  // getNextColor() {\r\n  //   const color = this.colorsArrayBackGround[this.currentColorIndex];\r\n  //   this.currentColorIndex = (this.currentColorIndex + 1) % this.colorsArrayBackGround.length;\r\n  //   return color;\r\n  // }\r\n\r\n  getNextColorForBackground() {\r\n    const color = this.colorsArrayBackGround[this.currentIndexBackgroundArray];\r\n    this.currentIndexBackgroundArray = (this.currentIndexBackgroundArray + 1) % this.colorsArrayBackGround.length;\r\n    return color;\r\n  }\r\n  \r\n  getNextColorFromSecondsCounter(array: string[]): string {\r\n    const color = array[this.currentIndexSecondsCounterArray];\r\n    this.currentIndexSecondsCounterArray = (this.currentIndexSecondsCounterArray + 1) % this.colorsArraySecondsCounter.length;\r\n    return color;\r\n  }\r\n\r\n  // these methods generates an array of colors that gradually changes from the starting color to the end color in a given number of steps (use 60 if you want to match a minute)\r\n  generateColorArray(startColor: string, endColor: string, steps: number): string[] {\r\n    const colorsArray = [];\r\n    const startRGB = this.extractRGBValues(startColor);\r\n    const endRGB = this.extractRGBValues(endColor);\r\n    for (let i = 0; i <= steps; i++) {\r\n      const currentColor = this.interpolateColor(startRGB, endRGB, i / steps);\r\n      colorsArray.push(`rgb(${currentColor.join(',')})`);\r\n    }\r\n    return colorsArray;\r\n  }\r\n\r\n  private extractRGBValues(color: string): number[] {\r\n    const matchResult = color.match(/\\d+/g);\r\n    if (matchResult) {\r\n      return matchResult.map(Number);\r\n    } else {\r\n      console.error('Invalid color format');\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private interpolateColor(startColor: number[], endColor: number[], ratio: number): number[] {\r\n    return startColor.map((component, index) =>\r\n      Math.round(component + (endColor[index] - component) * ratio)\r\n    );\r\n  }\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}